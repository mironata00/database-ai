from fastapi import APIRouter, Depends, HTTPException, status, Query, UploadFile, File, Form
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, or_, and_
from typing import List, Optional
import io
import uuid
from datetime import datetime

from app.core.database import get_db
from app.models.user import User
from app.models.supplier import Supplier
from app.models.email import EmailThread, EmailDirection
from app.api.auth import get_current_user
from app.utils.imap_client import IMAPClientPersonal
from app.utils.email_sender_personal import send_email_from_user_with_attachments
from app.utils.encryption import encryption
from app.utils.minio_client import minio_client
from pydantic import BaseModel

router = APIRouter()


class SendEmailRequest(BaseModel):
    to: str
    subject: str
    body: str
    reply_to: Optional[str] = None


class MarkReadRequest(BaseModel):
    folder: str = "INBOX"


async def find_supplier_by_email(db: AsyncSession, email: str) -> Optional[Supplier]:
    """Найти поставщика по email адресу"""
    email_clean = email.lower().strip()
    
    # Извлекаем email из формата "Name <email@domain.com>"
    if '<' in email_clean and '>' in email_clean:
        email_clean = email_clean.split('<')[1].split('>')[0].strip()
    
    result = await db.execute(
        select(Supplier).where(
            or_(
                Supplier.email == email_clean,
                Supplier.contact_email == email_clean
            )
        )
    )
    return result.scalar_one_or_none()


async def save_email_to_thread(
    db: AsyncSession,
    supplier_id: uuid.UUID,
    message_id: str,
    subject: str,
    from_addr: str,
    to_addr: List[str],
    body_text: str,
    body_html: Optional[str],
    direction: EmailDirection,
    cc_addr: Optional[List[str]] = None,
    bcc_addr: Optional[List[str]] = None,
    attachments: Optional[List[dict]] = None,
    in_reply_to: Optional[str] = None
):
    """Сохранить письмо в историю переписки"""
    email_thread = EmailThread(
        supplier_id=supplier_id,
        message_id=message_id,
        subject=subject,
        from_addr=from_addr,
        to_addr=to_addr,
        cc_addr=cc_addr,
        bcc_addr=bcc_addr,
        body_text=body_text,
        body_html=body_html,
        direction=direction,
        attachments=attachments,
        in_reply_to=in_reply_to
    )
    
    db.add(email_thread)
    await db.commit()
    await db.refresh(email_thread)
    
    return email_thread


@router.get("/config")
async def get_mail_config(
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Проверка настроек почты текущего пользователя"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(status_code=404, detail="Пользователь не найден")

    return {
        "has_smtp_configured": user.has_smtp_configured(),
        "has_imap_configured": user.has_imap_configured(),
        "has_email_configured": user.has_email_configured(),
        "smtp_user": user.smtp_user,
        "imap_user": user.imap_user
    }


@router.get("/folders")
async def get_folders(
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Получить список папок почты"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user or not user.has_imap_configured():
        raise HTTPException(status_code=400, detail="IMAP не настроен")

    try:
        client = IMAPClientPersonal(
            host=user.imap_host,
            port=user.imap_port,
            user=user.imap_user,
            password=user.imap_password,
            use_ssl=user.imap_use_ssl
        )
        folders = client.get_folders()
        return {"folders": folders}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка подключения к IMAP: {str(e)}")


@router.get("/messages")
async def get_messages(
    folder: str = Query("INBOX"),
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    unread_only: bool = Query(False),
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Получить список писем"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user or not user.has_imap_configured():
        raise HTTPException(status_code=400, detail="IMAP не настроен")

    try:
        client = IMAPClientPersonal(
            host=user.imap_host,
            port=user.imap_port,
            user=user.imap_user,
            password=user.imap_password,
            use_ssl=user.imap_use_ssl
        )
        messages = client.get_messages(
            folder=folder,
            limit=limit,
            offset=offset,
            unread_only=unread_only
        )
        return {"messages": messages, "total": len(messages)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка получения писем: {str(e)}")


@router.get("/messages/{msg_id}")
async def get_message(
    msg_id: str,
    folder: str = Query("INBOX"),
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Получить содержимое письма с сохранением вложений в MinIO"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user or not user.has_imap_configured():
        raise HTTPException(status_code=400, detail="IMAP не настроен")

    try:
        client = IMAPClientPersonal(
            host=user.imap_host,
            port=user.imap_port,
            user=user.imap_user,
            password=user.imap_password,
            use_ssl=user.imap_use_ssl
        )
        message = client.get_message_body(folder=folder, msg_id=msg_id)

        if "error" in message:
            raise HTTPException(status_code=404, detail=message["error"])

        # Сохраняем вложения в MinIO и заменяем на ссылки
        if message.get('attachments'):
            for idx, attachment in enumerate(message['attachments']):
                file_id = str(uuid.uuid4())
                timestamp = datetime.now().strftime('%Y%m%d')
                object_name = f"{timestamp}/{user.id}/{msg_id}/{file_id}_{attachment['filename']}"

                attachment_data = client.get_attachment(folder=folder, msg_id=msg_id, attachment_index=idx)

                if attachment_data and attachment_data.get('content'):
                    success = minio_client.upload_file(
                        bucket='email-attachments',
                        object_name=object_name,
                        data=attachment_data['content'],
                        content_type=attachment.get('content_type', 'application/octet-stream')
                    )

                    if success:
                        attachment['minio_path'] = object_name
                        attachment['download_index'] = idx

        # Сохраняем входящее письмо в историю (если отправитель - поставщик)
        try:
            from_email = message.get('from', '')
            supplier = await find_supplier_by_email(db, from_email)
            
            if supplier:
                attachments_data = []
                if message.get('attachments'):
                    for att in message['attachments']:
                        attachments_data.append({
                            'filename': att.get('filename'),
                            'content_type': att.get('content_type'),
                            'size': att.get('size'),
                            'minio_path': att.get('minio_path')
                        })
                
                await save_email_to_thread(
                    db=db,
                    supplier_id=supplier.id,
                    message_id=message.get('message_id', msg_id),
                    subject=message.get('subject', ''),
                    from_addr=from_email,
                    to_addr=[message.get('to', '')],
                    cc_addr=[message.get('cc')] if message.get('cc') else None,
                    body_text=message.get('body_text', ''),
                    body_html=message.get('body_html'),
                    direction=EmailDirection.INCOMING,
                    attachments=attachments_data if attachments_data else None,
                    in_reply_to=message.get('in_reply_to')
                )
        except Exception as e:
            # Не блокируем получение письма если не удалось сохранить в историю
            print(f"Error saving incoming email to thread: {e}")

        return message
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка получения письма: {str(e)}")


@router.get("/messages/{msg_id}/attachments/{attachment_index}")
async def download_attachment(
    msg_id: str,
    attachment_index: int,
    folder: str = Query("INBOX"),
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Скачать вложение из письма"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user or not user.has_imap_configured():
        raise HTTPException(status_code=400, detail="IMAP не настроен")

    try:
        client = IMAPClientPersonal(
            host=user.imap_host,
            port=user.imap_port,
            user=user.imap_user,
            password=user.imap_password,
            use_ssl=user.imap_use_ssl
        )

        attachment_data = client.get_attachment(
            folder=folder,
            msg_id=msg_id,
            attachment_index=attachment_index
        )

        if not attachment_data:
            raise HTTPException(status_code=404, detail="Вложение не найдено")

        return StreamingResponse(
            io.BytesIO(attachment_data['content']),
            media_type=attachment_data['content_type'],
            headers={
                'Content-Disposition': f'attachment; filename="{attachment_data["filename"]}"'
            }
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка скачивания вложения: {str(e)}")


@router.post("/messages/{msg_id}/read")
async def mark_as_read(
    msg_id: str,
    data: MarkReadRequest,
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Пометить письмо как прочитанное"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user or not user.has_imap_configured():
        raise HTTPException(status_code=400, detail="IMAP не настроен")

    try:
        client = IMAPClientPersonal(
            host=user.imap_host,
            port=user.imap_port,
            user=user.imap_user,
            password=user.imap_password,
            use_ssl=user.imap_use_ssl
        )
        success = client.mark_as_read(folder=data.folder, msg_id=msg_id)
        return {"success": success}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка: {str(e)}")


@router.post("/send")
async def send_email(
    to: str = Form(...),
    subject: str = Form(...),
    body: str = Form(...),
    reply_to: Optional[str] = Form(None),
    files: List[UploadFile] = File(default=[]),
    db: AsyncSession = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Отправить письмо с вложениями"""
    result = await db.execute(
        select(User).where(User.id == current_user.get("id"))
    )
    user = result.scalar_one_or_none()

    if not user or not user.has_smtp_configured():
        raise HTTPException(status_code=400, detail="SMTP не настроен")

    try:
        smtp_config = {
            'host': user.smtp_host,
            'port': user.smtp_port,
            'user': user.smtp_user,
            'password': user.smtp_password,
            'use_tls': user.smtp_use_tls,
            'from_name': user.smtp_from_name or user.full_name or user.smtp_user,
            'from_email': user.smtp_user
        }

        imap_config = None
        if user.has_imap_configured():
            imap_config = {
                'host': user.imap_host,
                'port': user.imap_port,
                'user': user.imap_user,
                'password': user.imap_password,
                'use_ssl': user.imap_use_ssl
            }

        # Подготовка вложений и сохранение в MinIO
        attachments = []
        minio_paths = []

        for file in files:
            content = await file.read()

            file_id = str(uuid.uuid4())
            timestamp = datetime.now().strftime('%Y%m%d')
            object_name = f"sent/{timestamp}/{user.id}/{file_id}_{file.filename}"

            minio_client.upload_file(
                bucket='email-attachments',
                object_name=object_name,
                data=content,
                content_type=file.content_type or 'application/octet-stream'
            )

            minio_paths.append({
                'filename': file.filename,
                'minio_path': object_name,
                'size': len(content),
                'content_type': file.content_type or 'application/octet-stream'
            })

            attachments.append({
                'filename': file.filename,
                'content': content,
                'content_type': file.content_type or 'application/octet-stream'
            })

        result = send_email_from_user_with_attachments(
            user_smtp_config=smtp_config,
            to_email=to,
            subject=subject,
            body=body,
            attachments=attachments,
            reply_to=reply_to,
            save_to_sent=True,
            imap_config=imap_config
        )

        result['minio_attachments'] = minio_paths

        # Сохраняем исходящее письмо в историю (если получатель - поставщик)
        try:
            supplier = await find_supplier_by_email(db, to)
            
            if supplier:
                message_id = result.get('message_id', f"{uuid.uuid4()}@{smtp_config['host']}")
                
                await save_email_to_thread(
                    db=db,
                    supplier_id=supplier.id,
                    message_id=message_id,
                    subject=subject,
                    from_addr=smtp_config['from_email'],
                    to_addr=[to],
                    body_text=body,
                    body_html=None,
                    direction=EmailDirection.OUTGOING,
                    attachments=minio_paths if minio_paths else None,
                    in_reply_to=reply_to
                )
                
                # Обновляем last_email_sent_at у поставщика
                supplier.last_email_sent_at = datetime.utcnow()
                await db.commit()
                
        except Exception as e:
            # Не блокируем отправку письма если не удалось сохранить в историю
            print(f"Error saving outgoing email to thread: {e}")

        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка отправки: {str(e)}")
